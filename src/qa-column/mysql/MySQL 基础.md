---
title: MySQL 基础
---

## 问题清单

::: tip Questions
1.   **执行一条 select 语句，经历了哪些流程？**

2.   **MySQL 空闲连接会一直被占用吗？**

3.   **MySQ L的连接数有限制吗？**

4.   **MySQL 执行期与存储引擎交互的具体操作是怎么样的？**

5.   **MySQL 数据存放在哪里？**

6.   **MySQL 表空间的文件结构是怎么样的？**

7.   **InnoDB 行 Row 格式有哪些？**

8.   **Compact 格式是什么样子的？**

9.   **为什么变长字段列表和 Null 值列表逆向存储？**

10.   **行溢出后，MySQL 如何处理？**

11.   **MySQL 的 InnoDB 与 MyISAM 引擎优缺点对比？**
::: 

## 问题回答

1.   **执行一条 select 语句，经历了哪些流程？**
::: info Answer
  `MySQL` 语句的执行是由 `Server` 层和存储引擎层负责的

  -   `Server` 层负责建立连接、分析和执行 `SQL`

  -   存储引擎层负责数据的存储和提取

      -   `InnoDB`、`MyISAM`、`Memory` 等引擎

  -   连接器

      1. 与 `MySQL` 服务器建立 `TCP` 连接

      2. 校验客户端的用户名和密码

      3. 获取用户权限，之后的逻辑判断基于此权限

  -   查询缓存

      - 缓存以 `key-value` 形式存储，`key` 为 `SQL` 语句，`value` 为查询结果

      - 但是只要一个表有更新操作，那么这个表的查询缓存就会被清空

  -   解析器

      -   对 `SQL` 语句进行词法分析、语法

  -   预处理器

      -   检查 `SQL` 查询语句中的表和字段是否存在

      -   将 * 转换为各列

  -   优化器

      -   负责将 `SQL` 语句的执行方案确定下来，选择最快的索引

  -   执行器

      -   根据执行方案，从存储引擎中读取数据，返回给客户端
:::

2.   **MySQL 空闲连接会一直被占用吗？**
::: info Answer
  并不会一直被占用，空闲连接的最大空闲时间由 `wait_timeout` 参数控制，默认值为 `28880` 秒，空闲连接超过该时间，会自动断开

  也可以选择手动切断连接
:::

3.   **MySQL 的连接数有限制吗？**
::: info Answer
  有限制的，超过 `max_connection` 则会拒绝之后的连接请求

  MySQL的连接又分为长连接与短连接

  一般推荐使用长连接。但是长连接存在长时间占用内存的问题。

  -   定期断开长连接，释放占据的内存资源
  
  -   客户端主动重置连接：主动调用该函数 `mysql_reset_connection`
:::

4.   **MySQL 执行期与存储引擎交互的具体操作是怎么样的？**
::: info Answer
  -   主键索引查询

      ```sql
      select * from tb where id = 1;
      ```

      优化器确定的访问类型为 `const`，使用主键索引查询一条记录

      -   第一次查询，调用 `read_first_record` 函数指针指向的函数，由于访问类型为 `const`，函数指针指向 `InnoDB` 引擎查询索引的接口，

          将条件交给存储引擎，存储引擎定位到第一条符合条件的记录

      -   通过 B+ 树定位到 `id=1` 的第一条记录。若记录不存在，则给执行器返回错误；否则，则将记录返回给执行器

      -   执行器拿到数据后判断是否符合查询条件，符合则返回给客户端，不符合则跳过

      -   执行器查询为 `while` 循环，这时函数指针会指向-1，因此再次调用时，执行器便会退出循环，结束查询

  -   全表扫描

      ```sql
      select * from tb where name = 'xxx';
      ```

      优化器确定的访问类型为 `all`

      -   第一次查询，调用 `read_first_record` 函数指针指向的函数，由于访问类型为 `all`，函数指针指向 `InnoDB` 引擎全扫描的接口，

          存储引擎读取表中的第一条记录

      -   执行期判断第一条记录是否符合条件，符合则发送给客户端，否则跳过

      -   执行期查询过程为 `while` 循环，一直重复此过程，直到把表中所有数据遍历一遍

  -   索引下推

      联合索引当遇到范围查询 (>、<) 就会停止匹配

      -   `Server` 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录

      -   存储引擎定位到二级索引后，**先不执行回表**操作，而是先判断一下该索引中包含的列（reward 列）的条件（reward 是否等于 100000）是否成立。

      -   `Server` 层在判断其他的查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。
      
      -   如此往复，直到存储引擎把表中的所有记录读完。
:::

5.   **MySQL 数据存放在哪里？**
::: info Answer
  存放在当前表对应的数据库同名文件夹中，里面有三个文件

  -   db.opt 存储数据库的默认字符集和字符校验规则

  -   xxx.frm 存储当前表的表结构
  
  -   xxx.ibd 存储当前表的表数据
:::

6.   **MySQL 表空间的文件结构是怎么样的？**
::: info Answer
  表空间由段 `Segment`、区 `Extent`、页 `Page`、行 `Row` 组成

  -   行 Row：数据库表的记录均是按照行进行存放的

  -   页 Page：`InnoDB` 的数据是按照页进行读取的，1 页为 16 KB。每次从磁盘读取和写入磁盘均是以页为单位，最少读取或写入 16KB

  -   区 Extent：当表数据量大时，就不按照页为单位给索引分配空间了，而是按照区为单位，这样可以使得B+树每一层链表中相邻的页在物理位置上相邻

      每个区大小为 1 MB，连续 64 个页会被划分为一个区，可以采用顺序 IO

  -   段 Segment：段一般分为数据段、索引段和回滚段等。

      -   索引段：存放 B + 树的非叶子节点的区的集合；

      -   数据段：存放 B + 树的叶子节点的区的集合；

      -   回滚段：存放的是回滚数据的区的集合
:::

7.   **InnoDB 行 Row 格式有哪些？**
::: info Answer
  Redundant、Compact、Dynamic、Compressed

  Redundant 基本没人使用，Dynamic 为默认格式
:::

8.   **Compact 格式是什么样子的？**
::: info Answer
  `Compact` 行分为记录的额外信息与记录的真实数据两个部分

  -   记录的额外信息包含 3 个部分：变长字段列表、Null 值列表、记录头信息

      -   变长字段列表为逆序存储，存储的是各个变长字段的长度（十六进制形式）。

      -   Null 值列表为逆序存储，每个允许存在 Null 值的列对应一个二进制位，二进制位按照逆序排列

          -   二进制位的值为 1 时，该列值为 null

          -   二进制位的值为 0 时，该列值不为 null

          -   Null 值列表必须用整数个字节的位表示，不足在字节高位补 0

              -   比如：有 3 个允许存在 Null 值的列时，逆序排列为 010，则 Null 值列表为 1 个字节 -> 00000010

                  有 9 个允许存在 Null 值的列时，逆序排列为 110111000，则 Null 值列表为 2 个字节 -> 00000001 10111000

          -   当数据表的所有字段都为 not null 时，行格式中就不会存在 Null 值列表

      -   记录头信息包含很多内容。如 delete_mask / next_record / record_type 等等

  -   记录的真实数据中除了每一列的数据外，还包含 row_id / trx_id / roll_ptr

      -   row_id：如果表中既没有主键，也没有唯一约束，那么 `InnoDB` 会为记录添加 `row_id`，占用 6 字节；否则则不添加

      -   trx_id：事务 ID，必须得有且占用 6 字节

      -   roll_pointer：记录上个版本的指针，必须得有且占用 7 字节
:::

9.   **为什么变长字段列表和 Null 值列表逆向存储？**
::: info Answer
  记录头信息中存在一个字段为next_record，指向下一条记录的记录头信息与真实数据之间的位置。

  这样的好处就是当跳转到下一条记录时，向左读就是记录信息，向右读就是真实数据
:::

10.   **行溢出后，MySQL 如何处理？**
::: info Answer
  发生行溢出后，多余的数据会存到另外的溢出页中，用20字节存储指向溢出页的地址，从而可以找到剩余溢出数据所在的页
:::

11.   **MySQL 的 InnoDB 与 MyISAM 引擎优缺点对比？**
::: info Answer
  -   事务支持：InnoDB 支持事务，MyISAM 不支持事务

  -   锁：InnoDB 支持表锁与行锁，锁粒度更小；而 MyISAM 只支持表锁

  -   外键支持：InnoDB 支持外键，MyISAM 不支持外键

  -   MVCC 支持：InnoDB 支持 MVCC，MyISAM 不支持 MVCC

  -   表的行数：MyISAM 保存有表的总行数，而 InnoDB 需要遍历整张表

  -   表主键：MyISAM 允许没有任何索引和主键的表存在，索引都是保存行的地址。对于 InnoDB，如果没有设定主键或者非空唯一索引，就会自动生成一个 6 字节的主键(用户不可见)。
  
  -   主键索引：InnoDB 支持主键索引，MyISAM 不支持主键索引
:::