---
title: MySQL 索引
---

## 问题清单

::: tip Questions
1.   **什么是索引？**

2.   **有哪些类型的索引？**

3.   **索引的好处？**

4.   **聚簇索引和二级索引的区别？**

5.   **为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？**

6.   **为什么 MySQL 不选择跳表作为索引的数据结构？**

7.   **主键索引、唯一索引、普通索引、前缀索引区别？**

8.   **单列索引、联合索引区别？**

9.   **索引下推优化是什么？**

10.   **什么时候需要索引？什么时候不需要索引？**

11.   **有什么优化索引的方法？**

12.   **为什么 MySQL 采用 B+ 树作为索引数据结构？**

13.   **MySQL索引失效的场景有哪些？**
::: 

## 问题回答

1.   **什么是索引？**
::: info Answer
  索引是帮助存储引擎快速获取数据的一种数据结构，**索引是数据的目录**，相当于书的目录
:::

2.   **有哪些类型的索引？**
::: info Answer
  可以按照4个角度对索引进行分类

  -   按照数据结构分类：`B+tree` 索引、`Hash` 索引、`Full-Text` 索引

  -   按照物理存储分类：聚簇索引（主键索引）、二级索引（辅助索引）

  -   按照字段特性分类：主键索引、唯一索引、普通索引、前缀索引

  -   按照字段个数分类：单列索引、联合索引

  创建表时，`InnoDB` 会根据不同场景选择不同的列作为索引

  -   如果有主键，就默认采用主键作为聚簇索引

  -   如果没有主键，就选择第一个不包含 `Null` 值的唯一列作为聚簇索引

  -   如果都没有，`InnoDB` 将自动生成一个隐式自增 `ID` 作为聚簇索引

  其他索引都属于辅助索引，也被称为耳机索引或非聚簇索引
:::

3.   **索引的好处？**
::: info Answer
  `B+Tree` 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 `I/O`，所以**B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。**
:::

4.   **聚簇索引和二级索引的区别？**
::: info Answer
  -   主键索引的 `B+Tree` 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 `B+Tree` 的叶子节点里；

  -   二级索引的 `B+Tree` 的叶子节点存放的是主键值，而不是实际数据。

      -   如果需要查的数据在二级索引中，则不需要回表；否则，需要根据二级索引中的主键值，再次回表查询主键索引，得到数据

          也就是说，需要通过两个 `B+Tree` 才能查到数据
:::

5.   **为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？**
::: info Answer
  -   `B+Tree` 只在叶子节点存储数据，而 `BTree` 的非叶子节点也要存储数据，所以 `B+Tree` 单个节点数据量更少，相同磁盘 `IO` 下，能查询更多节点

      此外，`B+Tree` 叶子节点采用双向链表，更适合范围顺序查找

  -   `B+Tree` 时间复杂度远低于二叉树，因为 `B+Tree` 的每个父节点的子节点个数一般是大于 100 的

  -   `B+Tree` 比 `Hash` 索引更适合做范围查询
:::

6.   **为什么 MySQL 不选择跳表作为索引的数据结构？**
::: info Answer
  -   对于读操作来说：

      -   `B+` 树是多叉树结构，每个节点都是一个 `16k` 的数据页，能够存放较多索引信息，三层就可以存放 `2kw` 左右数据

          查询某个数据，最多只需要 3 次磁盘 `IO`

      -   而跳表是链表结构，一个数据对应一个节点，如果最底层存放 `2kw` 数据且需要实现二分查找效果，则高度需要 24 层

          查询某个数据，最多需要 24 次磁盘 `IO`

      -   因此，从读效率来看，`B+` 树需要的磁盘 `IO` 次数远小于跳表

  -   对于写操作来说：

      -   `B+` 树在进行增加数据操作时，有可能需要对索引页进行拆分合并

      -   跳表是独立插入，并且在选取层数时，参照幂次定律随机生成一个层高，越大的数生成概率越小。

      -   因此，从写效率来看，跳表优于 `B+` 树
:::

7.   **主键索引、唯一索引、普通索引、前缀索引区别？**
::: info Answer
  -   主键索引是建立在主键字段上的索引，一张表最多一个主键索引，且该列不能有 `Null` 值

  -   唯一索引是建立在 `UNIQUE` 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是可以有 `Null` 值

  -   普通索引是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 `UNIQUE`

  -   前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 `char`、 `varchar`、`binary`、`varbinary` 的列上
:::    

8.   **单列索引、联合索引区别？**
::: info Answer
  -   单列索引：建立在单列上的索引称为单列索引

  -   联合索引：通过将多个字段组合成一个索引，该索引就被称为联合索引。

      -   使用联合索引时，存在**最左匹配原则**，也就是按照最左优先的方式进行索引的匹配

          如果不遵循「最左匹配原则」，联合索引会失效

      -   联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。**也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引**。

          -   对于 `a > 1 and b = 2`，只能利用联合索引中的a字段

          -   对于 `a >= 1 and b = 2`，可以利用联合索引，从第一条a = 1且b = 2的行数据开始查询

          -   对于 `a between 2 and 8 and b = 2`，可以利用联合索引，因为between代表大于等于和小于等于，包含边界值

          -   对于 `a like "j%" and b = 2`，可以利用联合索引，从符合 `a = 'j' and b = 2` 条件的第一条记录时开始扫描

      -   **联合索引的最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配**

      -   联合索引中将索引区分度大的字段排到前面，这样区分度大的字段越有可能被利用到
:::

9.   **索引下推优化是什么？**
::: info Answer
  在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数，不需要回表到主键索引判断
:::

10.   **什么时候需要索引？什么时候不需要索引？**
::: info Answer
  -   索引需要占用物理空间

  -   创建与维护索引耗费时间

  -   索引会降低增删改效率，因为每次增删改索引，`B+` 树会动态变化

  适合使用索引的场景

  -   字段有唯一性限制，比如各种编码 ID

  -   经常用于 `where` 查询条件的字段

  -   经常用于 `group by` 或者 `order by` 的字段

  不需要创建索引的场景

  -   字段中存在大量重复数据，如性别。在这些情况下，还不如不要索引，因为 `MySQL` 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。

  -   表数据很少时，不需要创建索引

  -   经常更新的字段不要创建索引，因为频繁的维护更新 `B+` 树十分影响数据库性能

  -   `WHERE` 条件，`GROUP BY`，`ORDER BY` 里用不到的字段
:::

11.   **有什么优化索引的方法？**
::: info Answer
  -   前缀索引优化

      使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。

      在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。

      前缀索引有一定的局限性，例如：

      -   `order by` 就无法使用前缀索引

      -   无法把前缀索引用作覆盖索引

  -   覆盖索引优化

      覆盖索引是指 `SQL` 中 `query` 的所有字段，在索引 `B+Tree` 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。

      使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 `I/O` 操作。

  -   主键索引最好自增

      这样每插入一条新纪录时，都是追加操作，不需要重新移动数据，因此这种插入数据方法效率很高

      如果使用非自增主键，每次插入主键的索引值都是随机的，每次插入新的数据，可能会插入现有数据页中间的一个位置，需要移动其他数据甚至从一个页面移动数据到另一个页面，即页分裂，会产生内存碎片，影响查询效率

  -   索引最好设置为 `NOT NULL`

      -   索引列存在 `NULL` 会导致优化器在做索引选择时更加复杂

      -   `NULL` 值是没有意义的值，还会占用物理空间

  -   防止索引失效

      -   使用左模糊或左右模糊匹配，会造成索引失效

      -   在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效

      -   联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。

      -   在 `WHERE` 子句中，如果在 `OR` 前的条件列是索引列，而在 `OR` 后的条件列不是索引列，那么索引会失效。
:::

12.   **为什么 MySQL 采用 B+ 树作为索引数据结构？**
::: info Answer
  `MySQL` 默认的存储引擎 `InnoDB` 采用的是 B+ 作为索引的数据结构，原因有：

  -   B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。

  -   B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化。

  -   B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。
:::

13.   **MySQL索引失效的场景有哪些？**
::: info Answer
  -   对索引使用左或者左右模糊匹配

      ```sql
      // name 字段为二级索引
      select * from t_user where name like '%林';
      ```

      **因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。**

  -   对索引使用函数

      ```sql
      // name 为二级索引
      select * from t_user where length(name)=6;
      ```

      因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。

  -   对索引进行表达式计算

      ```sql
      explain select * from t_user where id + 1 = 10;
      ```

  -   对索引隐式类型转换

      -   索引字段类型为varchar，但是查询条件为整型

          ```sql
          select * from t_user where phone = 1300000001;
          ```

          此时执行计划中 type = ALL，所以是通过全表扫描来查询数据的。

      -   索引字段类型为整型，但是查询条件为字符串

          ```sql
            explain select * from t_user where id = '1';
          ```

          不会导致索引失效

      -   **MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较**

          第一种情况相当于：CAST 函数作用在了 phone 字段，而 phone 字段是索引，也就是对索引使用了函数

          ```sql
          select * from t_user where CAST(phone AS signed int) = 1300000001;
          ```

          第二种情况相当于：CAST函数作用在了输入参数上

          ```sql
          select * from t_user where id = CAST("1" AS signed int);
          ```

  -   联合索引非最左匹配

      创建联合索引时，需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。

      `where a = 1 and c = 3`

      -   从 MySQL 5.6 之后，有一个**索引下推功能**，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。

      -   索引下推的大概原理是：截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 `(a, b, c)` 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。

  -   WHERE 子句中的 OR

      这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。
:::