---
title: Redis 持久化
---

## 问题清单

::: tip Questions
1.   **Redis 如何实现持久化？**

2.   **RDB 持久化的实现原理是什么？**

3.   **AOF 持久化的实现原理是什么？**

4.   **AOF 重写原理是什么？**

5.   **AOF 重写过程中，主进程什么时候会阻塞？**
::: 

## 问题回答

1.   **Redis 如何实现持久化？**
::: info Answer
  通过 `RDB` 持久化与 `AOF` 持久化实现，`RDB` 持久化为默认持久化方式，当开启 `AOF` 持久化后，采用 `AOF` 持久化。

  `Redis` 还提供了混合持久化方式，结合了 `RDB` 与 `AOF`，即 `AOF` 文件中第一部分是 `RDB` 的全量数据，第二部分是追加的写命令增量数据。
:::

2.   **RDB 持久化的实现原理是什么？**
::: info Answer
  `Redis` 通过自动保存机制，当满足一定条件，会将 `Redis` 内存上的数据持久化到 `RDB` 文件中。

  `RDB` 持久化的原理为利用 `serverCron` 定时任务，每隔一段时间自动执行一次，其中一项工作则是检查 `RDB` 持久化条件是否满足。

  默认的持久化条件为：服务器在 900s / 300s / 60s 内对数据库至少进行 1 / 10 / 10000 次操作，则开启持久化

  -   通过 `dirty` 和 `lastsave` 属性判断

  持久化的具体实现命令为：`save` / `bgsave`

  -   `save` 命令会阻塞 `redis` 服务器进程，而 `bgsave` 会创建一个子进程，后台进行持久化文件

  `RDB` 缺点在于其可能会造成数据丢失，在两次持久化的间隔时间内，`redis` 宕机会导致数据丢失
:::

3.   **AOF 持久化的实现原理是什么？**
::: info Answer
  `Redis` 在执行一个写命令后，会将正在执行的写命令追加到服务器 `aof_buff` 缓冲区末尾并写入 `AOF` 文件，但是真正的刷盘操作需要根据策略确定

  -   Always：每次执行写命令后，均会将 `page_cache` 中的写命令写入到硬盘

  -   Everysec：每隔一秒将 `page_cache` 中的写命令写入到硬盘，该操作由专门的线程进行负责

  -   No：不负责刷盘，何时刷盘由操作系统自行决定
:::

4.   **AOF 重写原理是什么？**
::: info Answer
  由于 `AOF` 原理是追加写命令，这会导致 `AOF` 文件过大，当文件大小超过一定阈值后，就会执行 `AOF` 重写机制

  -   创建新的 `aof` 文件，遍历全部数据库以及数据库中的全部 `key`，忽略已过期的 `key`，根据 `key` 类型对 `key` 进行重写，最后覆盖旧的 `aof` 文件
  -   创建新的 `aof` 文件目的在于防止 `aof` 重写失败，污染原有的 `aof` 文件

  `AOF` 可以通过 `bgrewriteof` 命令实现后台重写

  -   新创建一个后台子进程，进行重写操作，不影响主进程处理客户端请求

  -   后台重写的原理是利用了 **写时复制技术**

      -   当进行后台重写时，主进程会将页表复制一份给子进程，但是物理内存并没有进行复制，这时实现了共享数据，但是数据是只读的。

      -   当主进程收到客户端请求，去修改数据时，会修改物理内存数据，此时 `CPU` 会触发写保护中断，对被修改数据执行物理内存复制，不影响其他共享数据，并重新设置映射关系

      -   发生写时复制时，会造成主进程与子进程数据不一致，因此 `Redis` 设置了 `AOF` 重写缓冲区，主进程会将写命令追加到 `AOF` 缓冲区与重写缓冲区。

          当子进程结束重写后，会发送信号给父进程。父进程收到信号后，会调用信号处理函数，将AOF重写缓冲区中的所有内容追加到新的 `AOF` 文件中，并替换旧的 `AOF` 文件
:::

5.   **AOF 重写过程中，主进程什么时候会阻塞？**
::: info Answer
  1.   fork子进程

  2.   发生写时复制
  
  3.   主进程调用信号处理函数
:::