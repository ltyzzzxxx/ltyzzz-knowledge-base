---
title: Redis 缓存常见问题
---

## 问题清单

::: tip Questions
1.   **常见的缓存问题有哪些？**

2.   **缓存与数据库的一致性问题？**

3.   **如何解决第二步失败的问题？**

4.   **主从复制场景下带来了什么一致性问题？**

5.   **Redis 并发竞争 Key 问题如何解决？**
::: 

## 问答回答

1.   **常见的缓存问题有哪些？**
::: info Answer
  -   缓存穿透：客户端数据在缓存和数据库中都不存在，最终请求会到达数据库

      -   缓存空对象：当请求到达数据库，当数据库不存在时，则缓存一个空对象。之后再次请求时，则返回空对象

      -   布隆过滤器

      -   非法请求限制：用户明知道数据不存在，但是仍然在恶意查询，因此需要在 `API` 入口处判断请求参数是否合理

  -   缓存雪崩：同一时间段内有大量的key同时失效，导致大量请求进入数据库

      -   给不同的 `key` 设置随机的 `TTL` 值

      -   给缓存业务添加限流、降级、熔断等策略

      -   设置多级缓存

      -   构建高可用的 `Redis` 集群

  -   缓存击穿：热点 `key` 问题，被高并发访问的 `key` 失效，导致大量请求进入数据库

      -   互斥锁实现：并发线程中其中一个线程获取互斥锁并重建缓存，其余线程阻塞等待，重建之后其他线程再去查询

      -   逻辑过期：并发线程中其中一个线程发现逻辑时间过期，去获取互斥锁并重建缓存，其余线程直接返回过期数据，重建之后其他线程查询的为最新数据
:::

2.   **缓存与数据库的一致性问题？**
::: info Answer
  引入缓存后，选择更新缓存与数据库策略时，会引起不同程度的一致性问题。

  1.   先更新缓存后更新数据库 or 先更新数据库后更新缓存

      当二者之一宕机后，都会造成整体操作失败，从而造成一致性问题

  2.   并发操作共享资源会带来一致性问题，使得数据库与缓存的数据不一致

  并发操作需要加分布式锁去解决，而且从缓存利用率来看，及时地更新缓存并不可取，因为缓存数据并不会被马上被读取。

  因此需要采用新的策略：删除缓存

  1.   先删除缓存，后更新数据库

      并发问题：当 A 先删除了缓存，此时 B 读缓存发现不存在，然后从数据库中查询读到旧值，此时A更新了数据库，最后 B 将旧值写入了缓存

      -   此时缓存为旧值，数据库为新值，二者不一致

  2.   先更新数据库，后删除缓存

      并发问题：A 读缓存发现缓存不存在，去读取数据库得到旧值，B 更新数据库，然后删除缓存，A 将旧值写入缓存

      -   此时缓存为旧值，数据库为新值，二者不一致

      -   发生此问题的条件

          -   缓存刚好失效

          -   更新数据库 + 删除缓存时间 < 读数据库 + 写入缓存时间

          -   读写请求并发

      -   发生此问题的概率很小，因为写数据库需要加锁，耗时长
:::

3.   **如何解决第二步失败的问题？**

     需要确保两步均成功执行，如果第二步失败，则需要去重试执行第二步，保证最终一致性

     -   同步重试会导致一直占据 CPU 线程资源，并且如果当前系统宕机，则重试请求会丢失，将永远无法实现一致。

     因此需要依靠消息队列，采用异步重试方式实现一致性

     -   消息队列保证了可靠性，写到队列的消息，成功消费前不会丢失，可以持久化

     -   消息队列保证了消息成功投递，下游成功获取到消息并消费，消息才会被删除，否则将重试投递

     也可以依靠 canal 订阅 MySQL 更新日志，然后自动将日志投递到下游的消息队列，消息队列再投递消息去删除缓存

4.   **主从复制场景下带来了什么一致性问题？**

     1.   Redis 主库与从库之间的一致性问题

          -   主库有从库没有 - 复制延迟

          -   主库没有从库有 - 主库某 key 设置了过期时间，过期后短时间内能从从库读取到

          -   主库新增了数据，但还未来得及同步到从库中，主库宕机，从库晋升为新的主机时，丢失了部分数据

     2.   MySQL 主从复制延迟，造成数据库与缓存之间的一致性问题

          -   A 更新 MySQL 主库，并删除了缓存，B 查询缓存未命中，查询 MySQL 从库得到了旧值。此时 MySQL 主从同步完成，B 将旧值回种缓存

              此时 MySQL 存储的为新值，Redis 存储的为旧值

          -   需要采用延迟双删策略，且延迟时间需要大于 MySQL 主从同步时间

5.   **Redis 并发竞争 Key 问题如何解决？**

     1.   采用分布式锁

     2.   对 `key` 添加时间戳，即乐观锁思想。若获取的时间戳小于当前 `key` 的时间戳，则取消执行或继续重试

     3.   采用消息队列，将 `set` 操作串行化