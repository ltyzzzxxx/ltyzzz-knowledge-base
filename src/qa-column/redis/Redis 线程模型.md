---
title: Redis 线程模型
---

## 问题清单

::: tip Questions
1.   **如何理解 Redis 单线程模型？**

2.   **Redis 6.0 之前为什么不引入多线程？6.0 之后为什么引入多线程？**

3.   **对比一下各类网络 IO 模型？**

4.   **实现IO多路复用有哪几种方式？对比一下**
::: 


## 问题回答

1.   **如何理解 Redis 单线程模型？**

::: info Answer
  -   `Redis Server` 为多线程模型，有一些耗时的操作比如 `AOF` 刷盘操作等需要后台开启一个线程去执行

  -   但 `Redis` 处理客户端命令请求为单线程，其采用了 `IO多路复用` 模型实现了高性能

  具体 `IO多路复用` 模型是为了解决阻塞与非阻塞模型的效率低问题

  阻塞与非阻塞模型中，用户应用均需要以阻塞或自旋的方式读取网卡数据以及等待数据从内核态拷贝到用户态缓冲区，无法有效利用CPU

  `IO多路复用` 则是依赖于 `FD` 文件描述符，优先处理已经就绪的 `IO事件`

  -   利用一个线程监听多个 `FD`

  -   当某个 `FD` 可读、可写时得到通知，用户进程找到就绪的 `Socket`，依次调用 `recvfrom`

  -   此时内核拷贝数据到用户空间，用户进程处理数据
:::

2.   **Redis 6.0 之前为什么不引入多线程？6.0 之后为什么引入多线程？**

::: info Answer
  -   Redis的瓶颈并不在于性能，而是在于内存和网络延迟。

  -   引入多线程会提升复杂度，需要面临多线程下上下文切换成本、并发安全问题，开发与调试难度增大

  -   Redis6.0之后引入多线程专门用来处理网络I/O，以此充分利用CPU资源
:::

3.   **对比一下各类网络 IO 模型？**

::: info Answer
  -   阻塞 IO

      1.   用户进程调用 `recvfrom` 尝试读取数据，但此时数据未到达，进入阻塞等待状态

      2.   数据到达并拷贝到内核缓冲区，此时数据准备就绪

      3.   切换到内核态，将内核数据拷贝到用户缓冲区

      4.   用户进程解除阻塞，开始处理数据

      阻塞 IO 模式下，用户会从发起 `recvfrom` 指令开始，一直阻塞到数据拷贝到用户缓冲区

  -   非阻塞 IO

      1.   用户进程调用 `recvfrom` 尝试读取数据，但此时数据未到达，返回异常并循环读取

      2.   数据到达并拷贝到内核缓冲区，此时数据准备就绪，与此同时，用户进程进入阻塞态

      3.   切换到内核态，将内核数据拷贝到用户缓冲区

      4.   用户进程解除阻塞，开始处理数据

      `非阻塞IO` 模式下，用户会从发起 `recvform` 指令开始，循环读取数据。直到数据抵达内核缓冲区，用户进程进入阻塞状态。直到数据拷贝到用户缓冲区，用户进程解除阻塞，开始读取数据

  -   IO 多路复用

      利用单个线程来同时监听多个 `FD`，并在某个 `FD` 可读可写时得到通知，避免无效的等待，充分利用 `CPU` 资源

      1.   用户进程调用 `select` 函数，指定监听的 `FD` 集合，之后用户进程阻塞

      2.   任意一个或多个 `socket` 数据准备就绪则返回 `readable`，用户进程解除阻塞

      3.   用户进程找到就绪的 `socket`，依次调用 `recvfrom` 读取数据，内核拷贝数据到用户缓冲区，用户进程开始处理数据
:::

4.   **实现IO多路复用有哪几种方式？对比一下**

::: info Answer
  有三种方式：select、poll、epoll

  -   select / poll 与 epoll 对比：

      `select` 和 `poll` 都是当被监听的数据准备好之后，内核会将 `FD` 整个数据返回给用户态，然后用户态在遍历一遍 `FD` 集合，用户态获取数据的时间复杂度为 `O(n)`

      `epoll` 相当于内核数据准备好之后，会将准备好的这部分数据写入用户态缓冲区，用户态获取数据的时间复杂度为 `O(1)`，省去了遍历操作

  -   `select` 与 `poll` 对比

      `select` 的 `fd` 通过 `long` 数组进行存储，共 1024 个 `bit` 位，一个 `long` 位 32 位 4 字节，因此数组长度为 32。每个 `bit` 位代表一个 `fd`，0 为未就绪，1 为已就绪。

      `poll` 的 `fd` 通过链表进行存储，理论无上限，但是每次返回给用户态的数据仍然是整个 `fd` 数据。这意味着，监听的 `fd` 越多，遍历消耗时间越久，性能会下降

  -   `epoll` 通过红黑树保存需要监听的 `fd`，为每个 `fd` 设置一个监听函数，当 `fd` 准备就绪时触发该监听函数，并将准备就绪的 `fd` 添加到链表中。用户进程通过 `epoll_wait` 函数等待数据准备完毕
:::