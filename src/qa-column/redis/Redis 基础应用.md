---
title: Redis 基础应用
---

## 问题清单
::: tip Questions
1.   **为什么用 Redis 作为缓存？**

2.   **Redis 除了缓存之外的应用场景？**

3.   **Redis 实现消息队列有哪些方式？**

4.   **Redis 与 Memcached 对比？**

5.   **本地缓存、分布式缓存、多级缓存如何实现？**

6.   **为什么 Redis 采用跳表而不采用二叉树或平衡树？**

7.   **Redis 为什么不能做持久化数据库？**
::: 


## 问题回答

1.   **为什么用 Redis 作为缓存？**

::: info Answer
  Redis 通常可以用来当作缓存中间件

  -   基于内存的数据库，读写性能高

  -   `Redis` 底层设计了多种数据结构，被上层应用，提升了性能

  -   `Redis` 是单线程模型，避免了多线程的上下文切换、锁竞争、并发问题，对开发与调试友好，可维护性高

      -   `Redis Server` 是多线程的，但是其请求处理流程为单线程，所以一般认为 `Redis` 为单线程模型

  -   `Redis` 采用基于多路复用的 `I/O模型`，为 `select/epoll` 机制，一旦监听到 `FD` 上有请求到达，则会触发事件并放入消息队列中，等待处理

      `Redis` 一直在对事件队列进行处理，谁有数据就处理谁，实现了高性能
:::

2.   **Redis 除了缓存之外的应用场景？**
::: info Answer
  -   实现分布式锁

  -   实现消息队列

  -   实现限流器

  -   实现幂等性接口

  -   实现单点 `Token` 登陆（有状态）分布式 `Session`

  -   实现分布式 ID

  -   通过消息订阅机制实现聊天

  -   基于 `Redis` 提供的数据结构，实现排行榜、点赞关注列表、社交 Feed 流、签到统计、网站UV统计、地理坐标等
:::

3.   **Redis 实现消息队列有哪些方式？**
::: info Answer

1.   采用 `Redis` 的双向阻塞 `List`

     -   提供了 `LPUSH` 与 `RPOP` 以及阻塞式的 `BRPOP` 命令，满足消息有序且阻塞式获取消息的需求

     -   通过为每条消息设置全局唯一 ID 来确保可以处理重复消息

     -   消息可靠性：通过 `BRPOPLPUSH` 命令实现备份 `List`

     -   缺点：不支持多个消费者消费同一条消息

2.   采用 `Redis` 发布订阅模式 `PUB/SUB`

     -   只要发布者发布消息，所有订阅者都能收到消息，订阅者都是平等的。

     -   缺点：不支持持久化

3.   采用 `Redis` 的 `Stream`

     -   支持消息的持久化、支持自动生成全局唯一 ID、支持 ack 确认消息的模式、支持消费组模式

         -   `Redis` 本身数据结构自带持久化功能

         -   `XADD` 命令在插入数据时，自动生成全局唯一ID

         -   `XREAD` 命令读取消息队列时，支持设置 `BLOCK` 实现阻塞读

         -   消费组读取消息：同一消费组的消费者不能读取同一条消息，不同消费组的消费者可以读取同一条消息

         -   消息可靠性：`XPENDING` 命令查看已读取但未确认的消息，`XACK` 命令确认消息

     -   缺点：
         -   `Redis` 本身虽然做到了持久化机制，但仍然存在持久化失败的情况
         -   主从切换时造成数据丢失
         -   `Stream` 存在最大长度限制，消息积压概率大

     如果需要满足高可靠性，采用专业的消息队列 `RocketMQ`、`RabbitMQ`、`Kafka` 等。如：下单之后的一系列操作

     否则，可以使用 `Stream`。如：实时日志处理、实时数据采集、消息通知 
:::

4.   **Redis  与Memcached 对比？**
::: info Answer

  -   `Redis` 支持多种类型的数据结构，而 `Memcached` 只支持 `key-value` 字符串形式

  -   `Redis` 支持持久化，而 `Memcached` 不支持

  -   `Redis` 为单线程模型，而 `Memcached` 为多线程模型，采用多线程处理请求，充分利用多核，提升了 `IO` 效率

      数据量较大时，性能高于 `Redis`；数据量较小时，差别不大

  -   `Redis` 的内存淘汰策略较多，并且不需要设置内存上限；而 `Memcached` 只有 `LRU` 内存淘汰策略，且必须设置内存上限

  -   `Redis` 可以设置主从与哨兵来保证高可用性，而 `Memcached` 没有此功能

  -   `Redis` 采用固定哈希槽位实现集群化，而 `Memcached` 采用一致性哈希算法实现集群化
:::

5.   **本地缓存、分布式缓存、多级缓存如何实现？**
::: info Answer
  -   本地缓存：存储在本地应用进程当中，随着应用进程的消亡而消失

      -   优点：读取速度快，没有网络请求发送与传输的成本

      -   缺点：不支持持久化，不能够存储大量缓存数据，只存在于单个进程中，不能被多个进程共享

      -   实现：可以采用 `Java` 自身的 `HashMap`，也可以使用 `Guava`、`Hutool` 等本地缓存工具类库

  -   分布式缓存：部署于独立的缓存数据库中间件上，可以被多个分布式微服务应用共享

      -   优点：支持大量数据存储，部分中间件支持持久化，基于内存存储，速度较快

      -   缺点：性能低于本地缓存；在分布式场景下，部署和运维成本高（需要搭建集群保证高可用）

      -   实现：`Memcached`、`Redis`

  -   多级缓存：本地缓存作为一级缓存，分布式缓存作为二级缓存，最后一级为数据库
:::

6.   **为什么 Redis 采用跳表而不采用二叉树或平衡树？**
::: info Answer
  对比 `MySQL` 的索引数据结构来看：

  -   第一，B+ 树相对于跳表的优势就在于层数少，磁盘 `IO` 次数少

      而 `Redis` 是基于内存的数据库，因此不存在磁盘 `IO`，当然也不需要考虑此问题。`MySQL` 是基于磁盘存储，所以需要考虑磁盘 `IO`

  -   第二，B+ 树在进行插入时，需要进行合并与拆分节点以保持树的平衡，而跳表插入则不需要考虑这一点

      因此跳表写性能优于 B+ 树
:::

7. **Redis 为什么不能做持久化数据库？**
::: info Answer
-   内存宝贵

-   不支持事务回滚

-   断电故障问题

-   数据量过大时，会出现内存溢出

-   数据导出与数据分析，`MySQL` 支持将表结构与数据导出为 `SQL` 文件，而 `Redis` 不支持

-   `Redis6.0` 之前无法做到细粒度的权限控制
:::