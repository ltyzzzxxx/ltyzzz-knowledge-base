---
title: Redis 内存管理
---

## 问题清单

::: tip Questions
1.   **Redis 的内存淘汰机制是什么？**

2.   **LRU 与 LFU 是如何实现的？**

3.   **Redis 的过期删除策略是什么？**

4.   **定期删除的具体实现流程是什么？**
::: 


## 问题回答

1.   **Redis 的内存淘汰机制是什么？**

::: info Answer
  -   不进行数据淘汰：`noeviction`

      当运行内存超过最大限度时，会抛出 `OOM` 错误

  -   进行数据淘汰

      -   在设置过期时间的 `key` 中进行淘汰：

          -   `volatile-random`：随机淘汰

          -   `volatile-ttl`：优先淘汰更早过期的key

          -   `volatile-lru`：优先淘汰最久未使用的key

          -   `volatile-lfu`：优先淘汰使用频率最低的key

      -   在所有 `key` 中进行淘汰：`volatile-random` / `volatile-lru` / `volatile-lfu`
:::

2.   **LRU 与 LFU 是如何实现的？**

::: info Answer
  传统 LRU 实现：

  -   `LRU` 算法原理为通过链表从前向后记录最近一次使用过的 `key`。每次使用 `key` 时，都会将该 `key` 移动到链表的头部。

  -   需要进行内存淘汰时，删除链表尾部的 `key`

  -   问题为：需要用链表管理全部缓存数据，增加内存开销；每次使用 `key` 时，需要移动链表数据，性能低

  Redis LRU 实现：

  -   `Redis` 每一个 `key` 都有一个字段用于记录最后访问的时间。每次进行内存淘汰时，随机选取 5 个key，淘汰最久没有使用的 `key`。

  LRU 实质问题为：

  -   存在 `key` 污染，当一个大 `key` 只被读取一次，但是会长时间停留在内存中

  LFU实现：

  -   LFU算法原理是根据数据访问频率来淘汰数据，核心思想为：“若数据过去被访问过多次，那么将来也可能访问多次“

  -   相比于 `LRU`，`LFU` 除了记录上次访问的时间，还记录了数据访问频率

      -   高 16bit 数据用于记录上次访问的时间，低 8bit 数据用于记录数据访问频率 `logc`

      -   访问时的衰减操作：数据访问频率 `logc` 是会随着时间而衰减的，衰减的值与前后访问的时间差有关

          -   时间差越大，衰减值越大

      -   访问时的自增操作：对于 `logc` 值越大的 `key`，其 `logc` 值就越难增加
:::

3.   **Redis 的过期删除策略是什么？**

::: info Answer
  Redis 过期删除策略为：定时删除、定期删除、惰性删除

  -   定时删除：每个 `key` 绑定一个定时器，当超过过期时间时，将该 `key` 删除

      -   优点：可以保证过期 `key` 一旦过期，立马被删除，对于内存很友好

      -   缺点：对 `CPU` 不友好，每个 `key` 均需要对应一个定时器，不利于性能

  -   惰性删除

      -   优点：`CPU` 友好，简单实现

      -   缺点：内存不友好

  -   定期删除：每隔一段时间随机从 `Redis` 中选取一定数量的 `key` 进行判断。原理是 `serverCron` 定时任务

      -   优点：综合考虑了 `CPU` 与内存
      
      -   缺点：难以控制定期删除的时间间隔和每次删除花费的时间
:::

4.   **定期删除的具体实现流程是什么？**

::: info Answer

  -   遍历数据库，从过期字典获取当前数据库的带有过期时间 `key` 的数量

      -   若该数量为 0，则直接跳过这个数据库，接着遍历

      -   否则，挑选限定数量的 `key`，检查是否过期，若过期则直接删除

      -   如果本轮检查的已过期 `key` 数量超过了 25%，则继续检查；否则检查下一个数据库

  -   还需要判断当前处理时间是否到达时间上限，若到达则停止处理

  -   通过全局变量 `current_db` 记录检查进度，便于之后接着检查

  -   当数据库遍历一遍后，会重置 `current_db` 为 0
:::